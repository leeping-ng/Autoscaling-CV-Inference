# Communication Models

Summary of the pros, cons, use cases and packages used for request response, message queue and publish subscribe communication models in area of Computer Vision. These were my considerations when developing the [PeekingDuck Server](https://github.com/aisingapore/PeekingDuck/pull/697) feature. A good resource for understanding the trade-offs of these communication models: https://www.youtube.com/watch?v=DXTHb9TqJOs.

|                        | **Request Response**                                                                                                                                                                                                                            | **Message Queue**                                                                                                                                                                                                                                                                                                                 | **Publish Subscribe**                                                                                                                                                                                                                                                              |
|------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Pros**               | - Simple and well understood <br> - No need for intermediary e.g. broker or queue <br> - PKD users on producer side do not need to install additional packages or understand RabbitMQ etc, simple POST request will do                          | - Loose coupling, good for micro-services <br> - Durable comms, data won’t be lost when server goes down <br> - PKD user at client side doesn’t have to wait for response, good for UX <br> - Trait: Work is only executed one time, when message from queue has been consumed by any consumer, it will be wiped from queue       | - Loose coupling, good for micro-services <br> - Durable comms, data won’t be lost when server goes down <br> - PKD user at client side doesn’t have to wait for response, good for UX <br> - Trait: Message will only be wiped from queue when consumed by all of the subscribers |
| **Cons**               | - If server/client/network goes down, data is lost forever <br> - Server needs to have capacity to handle traffic <br>  - If synchronous: blocking operation, the client side will skip sending X frames while waiting for response from server | - Broker/intermediary is required <br> - PKD users need to set up broker, install packages, understand RabbitMQ etc <br> - Adds delays (compared to simple req-res) and complexity (but most of it is abstracted away) <br> - Need to understand RMQ behaviour if queue becomes very big due to fast producers and slow consumers | - Same as message queue                                                                                                                                                                                                                                                            |
| **Possible Use Cases** | - PKD users who just want to keep it simple and have low request rates <br> - Inference of images instead of videos <br> - Real-time performance not required, e.g. demo website for users to upload images                                     | - Cannot afford to lose any video frames, e.g. monitoring of critical infra <br> - Save cloud costs: split video frames up amongst various consumers <br> - No need to re-combine predicted frames into video, e.g. just need frames for the detection                                                                            | - Cannot afford to lose any video frames, e.g. monitoring of critical infra <br> - Multiple tasks for same video feed, e.g. 1 set of subscribers to detect fights, 1 set of subscribers to detect suspicious people (separate heavy CV models into different instances)            |
| **Choice of Tool**     | FastAPI - Faster performance compared to Flask. <br> Uvicorn - ASGI web server <br> Both are to be installed on server side. Python’s request can be used for POST requests on client side.                                                     | RabbitMQ chosen over NATS because it is more well known, which is important as our users will need to be familiar and run commands like  rabbitmq-server to use the broker. Note that RabbitMQ has to be installed on the broker machine, and pika installed on both producer and consumer.                                       | - Same as message queue                                                                                                                                                                                                                                                            |